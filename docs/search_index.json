[["index.html", "Rcpp 튜토리얼 들어가며", " Rcpp 튜토리얼 김현성 2024-06-22 들어가며 R은 통계를 전공하는 사람들이 가장 많이 사용하는 계산 언어 중 하나이다. R을 사용함에 있어 가장 답답한 부분 중 하나는 반복문(for문, while문)이 매우 매우 느리다는 것이다. 이러한 문제를 해결하는 방법 중 하나는 컴파일 언어인 C/C++ 또는 Fortran을 이용하는 것이지만, 이를 단기간에 배우는 것은 쉽지 않다. R에는 컴파일 언어인 C/C++을 사용하기 편리하도록 만들어진 Rcpp이라는 패키지가 있다. (Eddelbuettel, Francois, Allaire, et al. (2024)) 또한 C++에서 선형대수 라이브러리인 Eigen, Armadillo 또한 사용할 수 있도록 각각 RcppEigen (Bates et al. (2024)), RcppArmadillo (Eddelbuettel, Francois, Bates, et al. (2024))를 제공하고 있다. 여기서는 R 사용자를 위한 기본적인 Rcpp 사용법과 선형대수 연산을 위한 RcppEigen, RcppArmadillo의 사용법에 대해 정리한다. 필자 또한 C++을 전문적으로 배운 경험은 없으며, R 프로그래밍을 하며 연산속도 향상을 위해 부분적으로 C++을 사용하는 방법 위주로 정리해보려 한다. References Bates, Douglas, Dirk Eddelbuettel, Romain Francois, and Yixuan Qiu; the authors of Eigen for the included version of Eigen. 2024. RcppEigen: Rcpp Integration for the Eigen Templated Linear Algebra Library. https://github.com/RcppCore/RcppEigen. Eddelbuettel, Dirk, Romain Francois, JJ Allaire, Kevin Ushey, Qiang Kou, Nathan Russell, Inaki Ucar, Douglas Bates, and John Chambers. 2024. Rcpp: Seamless r and c++ Integration. https://www.rcpp.org. Eddelbuettel, Dirk, Romain Francois, Doug Bates, Binxiang Ni, and Conrad Sanderson. 2024. RcppArmadillo: Rcpp Integration for the Armadillo Templated Linear Algebra Library. https://github.com/RcppCore/RcppArmadillo. "],["install.html", "Chapter 1 설치하기 1.1 C/C++ 컴파일러 설치 1.2 패키지 설치", " Chapter 1 설치하기 1.1 C/C++ 컴파일러 설치 1.1.1 Windows Windows에서는 C/C++ 컴파일을 위해 Rtools의 설치가 필요하다. https://cran.r-project.org/bin/windows/Rtools/에서 본인의 R 버전에 맞는 것을 설치해주면 된다. 1.1.2 MacOS MacOS에서는 xcode의 설치가 필요하다. 프로그램이 다소 무거운 편이나, 앱스토어에서 간단히 설치할 수 있다. 1.1.3 Linux 1.2 패키지 설치 마지막으로 이제 R에서 아래의 패키지를 설치해주면 준비는 끝난다. # Rcpp 설치 install.packages(&quot;Rcpp&quot;) # RcppEigen 설치 install.packages(&quot;RcppEigen&quot;) # RcppArmadillo 설치 install.packages(&quot;RcppArmadillo&quot;) "],["cpp_basic.html", "Chapter 2 C++ 기초 문법 2.1 라이브러리 불러오기 2.2 변수선언 2.3 if 문 2.4 for 문 2.5 while 문 2.6 함수", " Chapter 2 C++ 기초 문법 2.1 라이브러리 불러오기 #include &lt;라이브러리 이름&gt;을 통해 C++ 라이브러리를 불러올 수 있다. R에서 library(패키지명)을 사용하는 것과 비슷하다. #include &lt;RcppEigen.h&gt; #include &lt;Rcpp.h&gt; 2.2 변수선언 2.2.1 R에서 변수선언 a &lt;- 1 # 정수형 b &lt;- 1.5 # 실수형 c &lt;- TRUE # 논리형 d &lt;- &quot;Rcpp&quot; # 문자형 2.2.2 C++에서 변수선언 int a = 1; // 정수형 double b = 1.5; // 실수형 bool c = true; // 논리형 char d = &quot;Rcpp&quot;; // 문자형 C++에서는 항상 코드 줄의 마지막에 ;(세미콜론)을 적어주어야 한다. 2.2.3 미리 선언 후 나중에 값 저장 int a; a = 100; R에서는 변수의 자료형을 지정해주지 않더라도 자동으로 자료형을 변환해주는 반면, C/C++에서는 자료형을 확실히 정해주어야 한다.1 2.3 if 문 2.3.1 R에서의 if 문 a &lt;- 10 if (a &lt; 5) { print(&quot;5보다 작다&quot;) } else if (a &lt; 8) { print(&quot;8보다 작다&quot;) } else { print(&quot;8보다 크다&quot;) } 2.3.2 C++에서의 if 문 int a = 10; if (a &lt; 5) { std::cout &lt;&lt; &quot;5보다 작다&quot; &lt;&lt; &quot;\\n&quot;; } else if (a &lt; 8) { std::cout &lt;&lt; &quot;8보다 작다&quot; &lt;&lt; &quot;\\n&quot;; } else { std::cout &lt;&lt; &quot;8보다 크다&quot; &lt;&lt; &quot;\\n&quot;; } C++에서 print를 하기 위해서는 C++ 표준 템플릿 라이브러리(STL : Standard Template Library) 내의 std::cout을 이용해야 한다. (Rcpp 내의 Rcpp::Rcout을 이용해도 된다.) 여기서 라이브러리::함수는 라이브러리 내의 함수에 접근한다는 의미로 R에서도 동일하게 사용되는 방법이다. R에서와 마찬가지로 라이브러리명을 제외하고 함수명으로만 사용하는 방법은 Namespace를 활용하는 방법이며 이는 Rcpp 파일의 구조 에서 설명하겠다. 2.4 for 문 2.4.1 R에서의 for 문 for (i in 1:10) { print(i) } 2.4.2 C++에서의 for 문 for (int i = 0; i &lt; 10; i++) { std::cout &lt;&lt; i &lt;&lt; &quot;\\n&quot;; } 2.5 while 문 2.5.1 R에서의 while 문 n &lt;- 0 while (n &lt; 5) { print(n) n &lt;- n + 1 } 2.5.2 C++에서의 while 문 int n = 0; while (n &lt; 5) { Rcpp::Rcout &lt;&lt; n &lt;&lt; &quot;\\n&quot;; n = n + 1; } 2.6 함수 2.6.1 R에서의 함수 정의 # 두 실수의 합을 구하는 함수 add &lt;- function(a, b) { val &lt;- a + b return(val) } 2.6.2 C++에서의 함수 정의 // 두 실수의 합을 구하는 함수 double add(double a, double b) { double val = a + b; return val; } C++에서 함수를 정의할 때 유의해야할 점은 input의 자료형과 output의 자료형을 반드시 명시해주어야 한다는 것이다. 아마 R 사용자에게 가장 익숙치 않은 부분일 것이고, 보통 여기서 에러가 매우 많이 발생한다. 이 부분을 항상 주의하도록 하자! 위의 4가지 뿐 아니라 실수의 자릿수 등을 더 디테일하게 정할 수 있는 자료형들이 존재하며 이는 많은 블로그들에서 확인할 수 있다.↩︎ "],["rcpp_structure.html", "Chapter 3 Rcpp 구조 3.1 Rcpp 파일의 구조 3.2 구조 뜯어보기", " Chapter 3 Rcpp 구조 3.1 Rcpp 파일의 구조 Rstudio에서는 File -&gt; New File -&gt; C++ File을 선택하여 C++ 파일을 만들 수 있다. 확장자는 파일명.cpp의 형태이며 기본으로 생성되는 파일은 다음과 같다. #include &lt;Rcpp.h&gt; using namespace Rcpp; // This is a simple example of exporting a C++ function to R. You can // source this function into an R session using the Rcpp::sourceCpp // function (or via the Source button on the editor toolbar). Learn // more about Rcpp at: // // http://www.rcpp.org/ // http://adv-r.had.co.nz/Rcpp.html // http://gallery.rcpp.org/ // // [[Rcpp::export]] NumericVector timesTwo(NumericVector x) { return x * 2; } // You can include R code blocks in C++ files processed with sourceCpp // (useful for testing and development). The R code will be automatically // run after the compilation. // /*** R timesTwo(42) */ 3.2 구조 뜯어보기 Rcpp을 사용하기 위한 라이브러리 로드 #include &lt;Rcpp.h&gt; namespace를 지정하여 앞에서 언급했던 라이브러리명::함수명 대신 함수명으로도 사용이 가능 using namespace Rcpp; // : C++에서의 주석 기호 C++ 함수 정의 // [[Rcpp::export]] NumericVector timesTwo(NumericVector x) { return x * 2; } [[Rcpp::export]]는 C++에서 정의한 함수를 R에서 사용할 수 있도록 해주는 구문 C++에서 R을 실행해보는 청크(Chunk) /*** R timesTwo(42) */ 인터프리터 언어인 R과 달리 C++은 컴파일 언어이기 때문에, 파일 전체를 컴파일하며 오류가 있는지 체크한다. 따라서 R처럼 한 줄씩 실행하며 코드에 오류가 있는지 확인하기 어려운데, 이 청크를 이용하여 컴파일과 동시에 함수가 잘 정의되었는지 확인할 수 있다. "],["rcpp_source.html", "Chapter 4 Rcpp 실행 4.1 sourceCpp()", " Chapter 4 Rcpp 실행 다음은 R에서 C++ 코드를 실행하는 함수이며, Rcpp 패키지 내의 함수이다. 4.1 sourceCpp() R 코드로 이루어진 파일(파일명.R)의 경우, source(파일명) 함수를 이용하여 R 소스코드를 실행할 수 있다. 이와 유사하게 R에서 C++ 소스코드(파일명.cpp)를 실행하는 함수는 sourceCpp(파일명)이다. 다음의 소스코드로 이루어진 test.cpp이라는 파일이 있다고 하자. (앞에서 다루었던 예시코드이다.) #include &lt;Rcpp.h&gt; using namespace Rcpp; // [[Rcpp::export]] NumericVector timesTwo(NumericVector x) { return x * 2; } C++에서는 함수 또는 클래스를 정의하기 때문에, sourceCpp()로 소스코드를 불러오게 되면, Global Environment에 timesTwo()라는 함수가 생성된 것을 확인할 수 있다. 따라서 C++ 코드로 짜여진 함수를 다음과 같이 R에서 사용할 수 있는 것이다. library(Rcpp) sourceCpp(&quot;test.cpp&quot;) timesTwo(1:5) 실행결과는 다음과 같다. [1] 1 4 9 16 25 "],["rcpp_datatype.html", "Chapter 5 Rcpp 자료형 5.1 Vector와 Matrix 5.2 List와 DataFrame", " Chapter 5 Rcpp 자료형 Rcpp은 Vector와 Matrix를 비롯해 List, DataFrame의 R과 비슷한 형태의 자료구조를 제공하고 있다. 5.1 Vector와 Matrix 다음의 표2에서 R과 Rcpp, C++의 Vector와 matrix에 해당하는 자료형을 비교하여 볼 수 있다. R에서는 Vector와 Scalar의 구분이 없지만, C++에서는 확실하게 구분되니 주의하자! 자료형 R Rcpp (Vector) Rcpp (Matrix) Rcpp (Scalar) C++ (Scalar) 정수형 integer IntegerVector IntegerMatrix - int 실수형 numeric NumericVector NumericMatrix - double 문자열 character CharacterVector (StringVector) CharacterMatrix (StringMatrix) String string 논리형 logical LogicalVector LogicalMatrix - bool 5.2 List와 DataFrame R Rcpp list List data.frame DataFrame 표는 https://teuder.github.io/rcpp4everyone_en/070_data_types.html#data.frame-list-s3-s4에서 일부를 가져왔으며, 링크에서 더 다양한 자료형을 확인할 수 있다.↩︎ "],["rcpp_vector.html", "Chapter 6 Vector 6.1 Vector 선언 6.2 Vector 값 접근 6.3 Vector 관련 함수", " Chapter 6 Vector 설명의 편의를 위해 using namespace Rcpp;를 선언했다고 가정하자. (즉, Rcpp:: 부분을 생략한다는 의미이다.) 6.1 Vector 선언 다음과 같이 여러 방법으로 Vector를 생성할 수 있다. NumericVector뿐 아니라 다른 타입의 Vector도 동일한 방법으로 사용이 가능하다. // 값을 지정하지 않고 자료형과 변수만 선언 NumericVector a; // a &lt;- rep(0, 3) NumericVector a(3); // a &lt;- c(1,2,3) NumericVector a = {1,2,3}; // 또는 NumericVector a = NumericVector::create(1,2,3); 6.2 Vector 값 접근 R과 달리 Vector의 인덱스는 0부터 시작한다. (이는 Python이나 다른 프로그래밍 언어에서도 마찬가지이다.) Vector의 인덱싱은 다음과 같이 할 수 있다. NumericVector a = {1,2,3,4,5}; double a1 = a[0]; // 1을 a1에 저장 double a3 = a[2]; // 3을 a3에 저장 NumericVector b = a[Rcpp::Range(1, 3)]; // c(2,3,4)를 b에 저장 위와 같이 Vector의 인덱싱과 슬라이싱을 할 수 있지만, 슬라이싱이 아닌 경우의 Vector의 값을 여러개 가져오는 것은 불가능하다. 즉, 위의 a라는 Vector에서 2와 5의 값만을 동시에 가져오는 방법은 불가능하다. 6.3 Vector 관련 함수 a라는 Vector 타입의 변수가 있다고 가정하자. 6.3.1 a.length(), a.size() Vector a의 길이 반환 6.3.2 a.sort() Vector a를 오름차순으로 정렬 "],["rcpp_matrix.html", "Chapter 7 Matrix 7.1 Matrix 선언 7.2 Matrix 값 접근 7.3 Matrix 관련 함수", " Chapter 7 Matrix 7.1 Matrix 선언 // 값을 지정하지 않고 자료형과 변수만 선언 NumericMatrix A; // A1 &lt;- matrix(0, nrow = 2, ncol = 2) NumericMatrix A1(2); // A2 &lt;- matrix(0, nrow = 2, ncol = 3) NumericMatrix A2(2, 3); 7.2 Matrix 값 접근 Vector와 마찬가지로 matrix에서도 인덱싱과 슬라이싱을 할 수 있지만, 연속적인 위치가 아닌 값들을 동시에 가져오는 것은 불가능하다. 다음의 코드를 확인해보자. NumericMatrix A(5, 5); // A[2, 3] double a11 = A(1, 2); // A[1, ] NumericVector row1 = A(0, _); // 또는 NumericVector row1 = A.row(0); // A[, 2] NumericVector col1 = A(_, 1); // 또는 NumericVector col1 = A.column(1); // A[1:2, 3:4] NumericMatrix B = A(Range(0, 1), Range(2, 3)); 7.3 Matrix 관련 함수 A라는 Matrix 타입의 변수가 있다고 가정하자. 7.3.1 A.nrow(), A.rows() Matrix A의 행 개수 반환 7.3.2 A.ncol(), A.cols() Matrix A의 열 개수 반환 7.3.3 A.row(i) Matrix A의 i번쨰 행 반환 (return 타입은 Vector) 7.3.4 A.col(j) Matrix A의 j번쨰 열 반환 (return 타입은 Vector) 7.3.5 transpose(A) Matrix A를 transpose한 Matrix 반환 (return 타입은 Matrix) "],["rcpp_list.html", "Chapter 8 List 8.1 List", " Chapter 8 List 8.1 List "],["rcpp_dataframe.html", "Chapter 9 DataFrame 9.1 DataFrame", " Chapter 9 DataFrame 9.1 DataFrame "],["r_like_function.html", "Chapter 10 R과 비슷한 함수", " Chapter 10 R과 비슷한 함수 "],["rcpp_use_r_function.html", "Chapter 11 R 함수 사용하기 11.1 R 패키지 내의 함수 사용", " Chapter 11 R 함수 사용하기 계산속도를 높이기 위해 Rcpp을 사용하지만, 이미 R에서 짜여진 함수를 다시 C++ 코드로 수정하는 것 또한 매우 어려운 일이다. 하지만 다음과 같은 형식으로 R 패키지에 있는 함수를 C++ 구문에서 사용할 수 있다. 11.1 R 패키지 내의 함수 사용 패키지의 포함된 함수의 경우는 다음과 같이 Environment를 설정해주어 R 함수 사용이 가능하다. 다음은 MASS 패키지의 huber() 함수를 사용하는 예시이다. // [[Rcpp::export]] double huber_cpp(Rcpp::NumericVector x) { // R 패키지 Environment 가져오기 Rcpp::Environment env(&quot;package:MASS&quot;); // MASS::huber() 함수를 가져와서 &quot;huber_r&quot;이라는 함수로 사용한다는 설정 Rcpp::Function huber_r = env[&quot;huber&quot;]; // 위에서 지정한 함수명으로 R 함수 실행(함수의 input은 List 형태로 들어감) return huber_r(Rcpp::_[&quot;y&quot;] = x, Rcpp::_[&quot;k&quot;] = 1.5); } "],["rcpp_use_header.html", "Chapter 12 C++ 코드 분리하기 12.1 header 파일 12.2 main 함수", " Chapter 12 C++ 코드 분리하기 R에서 source(R_file)과 같이 같은 C++ 함수를 다른 C++ 코드에서 사용하고자 할 때는 header 파일을 만들어서 사용할 수 있다. header 파일은 .cpp 파일과 비슷하지만 .h 확장자를 가지고, 함수의 namespace 등을 정리해놓은 파일로 볼 수 있다. (즉, 여기에 있는 함수가 다른 cpp 파일에 있을테니 찾아서 쓰라는 것으로 생각해볼 수 있을 것 같다.) 이제 다음과 같이 2개의 cpp 파일과 1개의 header 파일을 만든다. functions.cpp functions.h main_code.cpp 12.1 header 파일 먼저 다른 파일로 정의된 functions.cpp에 add()라는 함수가 정의되어 있다. 이 함수를 main_code.cpp에서 불러와 사용하기 위한 header 파일을 만들 것이다. 이에 앞서 functions.cpp에 다음과 같이 #include \"functions.h\"를 추가해준다. functions.cpp // functions.cpp #include &quot;functions.h&quot; // 이 부분을 추가해준다 int add(int a, int b) { return a + b; } 위 cpp 파일에 대응되는 header 파일을 다음과 같이 만든다. functions.cpp에 포함되어 있는 add() 함수에 대한 namespace를 넣어준다. functions.h // functions.h #ifndef FUNCTIONS_H // #ifndef ~ #endif로 묶어주고 #define FUNCTIONS_H // #define 으로 header 파일을 정의 int add(int a, int b); // functions.cpp 파일의 add() 함수에 대한 namespace #endif 12.2 main 함수 main 코드에서는 #include \"functions.h\"를 추가하여 functions.cpp에 포함된 add() 함수를 사용할 수 있다. main_code.cpp #include &lt;Rcpp.h&gt; #include &quot;functions.h&quot; using namespace Rcpp; // [[Rcpp::export]] int addTwoNumbers(int a, int b) { return add(a, b); } /*** R addTwoNumbers(1, 3) */ [1] 4 "],["eigen_basic.html", "Chapter 13 Eigen 불러오기", " Chapter 13 Eigen 불러오기 R에서 install.package(\"RcppEigen\")으로 RcppEigen을 설치하고, C++ 파일에서 Eigen을 사용할 떄에는 다음과 같이 불러올 수 있다. //[[Rcpp::depends(RcppEigen)]] #include &lt;RcppEigen.h&gt; 참고로 RcppEigen을 불러오면 자동으로 Rcpp까지 불러오기 떄문에 따로 #include &lt;Rcpp.h&gt;를 추가할 필요는 없다. "],["eigen_datatype.html", "Chapter 14 Eigen 자료형 14.1 Vector 14.2 Matrix", " Chapter 14 Eigen 자료형 설명의 편의를 위해 using namespace RcppEigen;를 선언했다고 가정하자. (즉, RcppEigen:: 부분을 생략한다는 의미이다.) 14.1 Vector 14.1.1 Vector 선언 다음과 같이 여러 방법으로 Vector를 생성할 수 있다. 여기서는 VectorXd를 이용해서 double type의 값을 가지는 vector를 생성했다. (여기서 X는 동적(dynamic) 크기를 할당한다는 의미이며, d는 double 형 값을 가진다는 의미이다.) 이외에도 VectorXf(float type의 동적 vector), VectorXi(integer type의 동적 vector)와 같은 방식으로 사용이 가능하다. // 값을 지정하지 않고 자료형과 변수만 선언 VectorXd a; // a &lt;- rep(0, 3) VectorXd a(3); // a &lt;- c(1,2,3) // 값을 바로 지정하면서 vector를 생성할 때에는 vector의 크기도 명확히 지정해주어야 한다. Vector3d a(1, 2, 3); 14.1.2 Vector 값 접근 Vector의 인덱싱은 다음과 같이 할 수 있다. VectorXd a(3); // Rcpp과 달리 [] 대신 () 를 이용해서 indexing a(0) = 3; a(1) = 4; a(2) = 5; // a = [3, 4, 5] 인 vector 슬라이싱은 seq() 또는 seqN()을 이용해서 할 수 있다. 여기서 a = [1, 2, 3, ..., 9]인 vector라 하자. // seq(start_idx, end_idx) a(seq(2, 5)) // Output: 3 4 5 6 // seq(start_idx, end_idx, 간격) a(seq(2, 6, 2)) // Output: 3 5 7 // seqN(start_idx, size) a(seqN(2, 3)) // Output: 3 4 5 // seqN(start_idx, size, 간격) a(seqN(2, 3, 2)) // Output: 3 5 7 14.1.3 Vector 관련 함수 a라는 Vector 타입의 변수가 있다고 가정하자. a.size(): a의 길이 반환 14.2 Matrix 14.2.1 Matrix 선언 // 값을 지정하지 않고 자료형과 변수만 선언 MatrixXd A; // A1 &lt;- matrix(0, nrow = 2, ncol = 3) MatrixXd A1(2, 3); 14.2.2 Matrix 값 접근 MatrixXd A(5, 5); // A[2, 3] double a11 = A(1, 2); // A[1, ] VectorXd row1 = A.row(0); // A[, 2] VectorXd col1 = A.col(1); // A[1:2, 3:4] MatrixXd B = A(seq(0, 1), seq(2, 3)); 14.2.3 Matrix 관련 함수 A라는 Matrix 타입의 변수가 있다고 가정하자. A.rows(): A의 행 개수 반환 A.cols(): A의 열 개수 반환 A.row(i): A의 i번쨰 행 반환 (return 타입은 Vector) A.col(j): A의 j번쨰 열 반환 (return 타입은 Vector) A.transpose(): A를 transpose한 Matrix 반환 (return 타입은 Matrix) "],["eigen_operation.html", "Chapter 15 Eigen Matrix 연산 15.1 Matrix 덧셈, 뺄셈 15.2 스칼라 곱셈, 나눗셈 15.3 Matrix 곱셈 15.4 내적, 외적 15.5 Elementwise 연산 15.6 연산 관련 함수들", " Chapter 15 Eigen Matrix 연산 다음의 변수들이 정의되어 있다고 하자. A: \\(n \\times p\\) 인 Eigen::MatrixXd B: \\(p \\times q\\) 인 Eigen::MatrixXd v: \\(p\\)차원 Eigen::VectorXd w: \\(p\\)차원 Eigen::VectorXd 15.1 Matrix 덧셈, 뺄셈 // A + A A + A // A - A A - A 15.2 스칼라 곱셈, 나눗셈 // 3 * A (scalar x matrix) 3 * A // A / 2 (matrix / scalar) A / 2 // 2 * v (scalar x vector) 2 * v 15.3 Matrix 곱셈 // A %*% B (matrix %*% matrix) A * B // A %*% v (matrix %*% vector) A * v 15.4 내적, 외적 // 내적(dot product) v.dot(w) // 외적(cross product) v.cross(w) 15.5 Elementwise 연산 Matrix의 elementwise 연산은 .array() method로 할 수 있다. // A + 1 (matrix A의 elementwise 곱셈) A.array() * 1 // A * A (matrix A의 elementwise 곱셈) A.array() * A.array() 15.6 연산 관련 함수들 // matrix A의 모든 원소의 합 A.sum() // trace of A A.trace() "],["arma_basic.html", "Chapter 16 Armadillo 불러오기 16.1 Mac에서 오류 발생 시", " Chapter 16 Armadillo 불러오기 R에서 install.package(\"RcppArmadillo\")으로 RcppArmadillo을 설치하고, C++ 파일에서 Armadillo을 사용할 떄에는 다음과 같이 불러올 수 있다. //[[Rcpp::depends(RcppArmadillo)]] #include &lt;RcppArmadillo.h&gt; 참고로 RcppArmadillo을 불러오면 자동으로 Rcpp까지 불러오기 떄문에 따로 #include &lt;Rcpp.h&gt;를 추가할 필요는 없다. (오히려 Rcpp을 추가로 불러오게 되면 에러가 발생한다!) 16.1 Mac에서 오류 발생 시 Mac에서 RcppArmadillo를 사용하여 C++ 코드를 컴파일 했을 때, 아래의 오류가 발생할 수 있다. library not found for -lgfortran 이는 Fortran 라이브러리 경로를 찾지 못했을 때 발생하며, 환경변수를 설정하여 해결할 수 있다. 터미널에서 아래 코드로 gfortran이 설치되어 있으면 다음으로 넘어가고, gfortran --version 설치가 되어있지 않을 경우에는 아래 명령어로 gfortran을 설치해준다. brew install gfortran 다음으로 “~/.R/Makevars” 파일을 생성해주고 mkdir -p ~/.R touch ~/.R/Makevars “~/.R/Makevars” 파일을 열어 아래의 내용을 추가한 후 저장한다. FLIBS = -L/usr/local/opt/gcc/lib/gcc/current -lgfortran -lquadmath -lm 이상이 없다면 R을 종료하고 다시 실행하게 되면 에러가 발생하지 않을 것이다. "],["arma_datatype.html", "Chapter 17 Armadillo 자료형 17.1 Vector 17.2 Matrix", " Chapter 17 Armadillo 자료형 17.1 Vector 17.2 Matrix "],["references.html", "References", " References Bates, Douglas, Dirk Eddelbuettel, Romain Francois, and Yixuan Qiu; the authors of Eigen for the included version of Eigen. 2024. RcppEigen: Rcpp Integration for the Eigen Templated Linear Algebra Library. https://github.com/RcppCore/RcppEigen. Eddelbuettel, Dirk, Romain Francois, JJ Allaire, Kevin Ushey, Qiang Kou, Nathan Russell, Inaki Ucar, Douglas Bates, and John Chambers. 2024. Rcpp: Seamless r and c++ Integration. https://www.rcpp.org. Eddelbuettel, Dirk, Romain Francois, Doug Bates, Binxiang Ni, and Conrad Sanderson. 2024. RcppArmadillo: Rcpp Integration for the Armadillo Templated Linear Algebra Library. https://github.com/RcppCore/RcppArmadillo. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
