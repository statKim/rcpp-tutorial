[["index.html", "Rcpp과 RcppEigen 튜토리얼 들어가며", " Rcpp과 RcppEigen 튜토리얼 김현성 2021-08-08 들어가며 R은 통계를 전공하는 사람들이 가장 많이 사용하는 계산 언어 중 하나이다. R을 사용함에 있어 가장 답답한 부분 중 하나는 반복문(for문, while문)이 매우 매우 느리다는 것이다. 이러한 문제를 해결하는 방법 중 하나는 컴파일 언어인 C/C++ 또는 Fortran을 이용하는 것이지만, 이를 단기간에 배우는 것은 쉽지 않다. R에는 컴파일 언어인 C/C++을 사용하기 편리하도록 만들어진 Rcpp이라는 패키지가 있다. (Eddelbuettel et al. (2021)) 또한 C++에서 선형대수 라이브러리인 Eigen, Armadillo 또한 사용할 수 있도록 각각 RcppEigen, RcppArmadillo를 제공하고 있다. 여기서는 Rcpp과 선형대수 연산을 위한 RcppEigen을 사용하는 방법에 대해 정리해본다. 필자도 C++을 전문적으로 배운 경험은 없으며, R 프로그래밍을 하며 연산속도 향상을 위해 부분적으로 C++을 사용하는 방법 위주로 정리해보려 한다. References "],["install.html", "Chapter 1 설치하기 1.1 C/C++ 컴파일러 설치 1.2 패키지 설치", " Chapter 1 설치하기 1.1 C/C++ 컴파일러 설치 1.1.1 Windows Windows에서는 C/C++ 컴파일을 위해 Rtools의 설치가 필요하다. https://cran.r-project.org/bin/windows/Rtools/에서 본인의 R 버전에 맞는 것을 설치해주면 된다. 1.1.2 MacOS MacOS에서는 xcode의 설치가 필요하다. 프로그램이 다소 무거운 편이나, 앱스토어에서 간단히 설치할 수 있다. 1.1.3 Linux 1.2 패키지 설치 마지막으로 이제 R에서 아래의 패키지를 설치해주면 준비는 끝난다. # Rcpp 설치 install.packages(&quot;Rcpp&quot;) # RcppEigen 설치 install.packages(&quot;RcppEigen&quot;) "],["cpp-basic.html", "Chapter 2 C++ 기초 문법 2.1 라이브러리 불러오기 2.2 변수선언 2.3 if 문 2.4 for 문 2.5 while 문 2.6 함수", " Chapter 2 C++ 기초 문법 2.1 라이브러리 불러오기 #include &lt;라이브러리 이름&gt;을 통해 C++ 라이브러리를 불러올 수 있다. R에서 library(패키지명)을 사용하는 것과 비슷하다. #include &lt;RcppEigen.h&gt; #include &lt;Rcpp.h&gt; 2.2 변수선언 2.2.1 R에서 변수선언 a &lt;- 1 # 정수형 b &lt;- 1.5 # 실수형 c &lt;- TRUE # 논리형 d &lt;- &quot;Rcpp&quot; # 문자형 2.2.2 C++에서 변수선언 int a = 1; // 정수형 double b = 1.5; // 실수형 bool c = true; // 논리형 char d = &quot;Rcpp&quot;; // 문자형 C++에서는 항상 코드 줄의 마지막에 ;(세미콜론)을 적어주어야 한다. 2.2.3 미리 선언 후 나중에 값 저장 int a; a = 100; R에서는 변수의 자료형을 지정해주지 않더라도 자동으로 자료형을 변환해주는 반면, C/C++에서는 자료형을 확실히 정해주어야 한다.1 2.3 if 문 2.3.1 R에서의 if 문 a &lt;- 10 if (a &lt; 5) { print(&quot;5보다 작다&quot;) } else if (a &lt; 8) { print(&quot;8보다 작다&quot;) } else { print(&quot;8보다 크다&quot;) } 2.3.2 C++에서의 if 문 int a = 10; if (a &lt; 5) { std::cout &lt;&lt; &quot;5보다 작다&quot; &lt;&lt; &quot;\\n&quot;; } else if (a &lt; 8) { std::cout &lt;&lt; &quot;8보다 작다&quot; &lt;&lt; &quot;\\n&quot;; } else { std::cout &lt;&lt; &quot;8보다 크다&quot; &lt;&lt; &quot;\\n&quot;; } C++에서 print를 하기 위해서는 C++ 표준 템플릿 라이브러리(STL : Standard Template Library) 내의 std::cout을 이용해야 한다. (Rcpp 내의 Rcpp::Rcout을 이용해도 된다.) 여기서 라이브러리::함수는 라이브러리 내의 함수에 접근한다는 의미로 R에서도 동일하게 사용되는 방법이다. R에서와 마찬가지로 라이브러리명을 제외하고 함수명으로만 사용하는 방법은 Namespace를 활용하는 방법이며 이는 Rcpp 파일의 구조 에서 설명하겠다. 2.4 for 문 2.4.1 R에서의 for 문 for (i in 1:10) { print(i) } 2.4.2 C++에서의 for 문 for (int i = 0; i &lt; 10; i++) { std::cout &lt;&lt; i &lt;&lt; &quot;\\n&quot;; } 2.5 while 문 2.5.1 R에서의 while 문 n &lt;- 0 while (n &lt; 5) { print(n) n &lt;- n + 1 } 2.5.2 C++에서의 while 문 int n = 0; while (n &lt; 5) { Rcpp::Rcout &lt;&lt; n &lt;&lt; &quot;\\n&quot;; n = n + 1; } 2.6 함수 2.6.1 R에서의 함수 정의 # 두 실수의 합을 구하는 함수 add &lt;- function(a, b) { val &lt;- a + b return(val) } 2.6.2 C++에서의 함수 정의 // 두 실수의 합을 구하는 함수 double add(double a, double b) { double val = a + b; return val; } C++에서 함수를 정의할 때 유의해야할 점은 input의 자료형과 output의 자료형을 반드시 명시해주어야 한다는 것이다. 아마 R 사용자에게 가장 익숙치 않은 부분일 것이고, 보통 여기서 에러가 매우 많이 발생한다. 이 부분을 항상 주의하도록 하자! 위의 4가지 뿐 아니라 실수의 자릿수 등을 더 디테일하게 정할 수 있는 자료형들이 존재하며 이는 많은 블로그들에서 확인할 수 있다. "],["rcpp-structure.html", "Chapter 3 Rcpp 구조 3.1 Rcpp 파일의 구조 3.2 구조 뜯어보기", " Chapter 3 Rcpp 구조 3.1 Rcpp 파일의 구조 Rstudio에서는 File -&gt; New File -&gt; C++ File을 선택하여 C++ 파일을 만들 수 있다. 확장자는 파일명.cpp의 형태이며 기본으로 생성되는 파일은 다음과 같다. #include &lt;Rcpp.h&gt; using namespace Rcpp; // This is a simple example of exporting a C++ function to R. You can // source this function into an R session using the Rcpp::sourceCpp // function (or via the Source button on the editor toolbar). Learn // more about Rcpp at: // // http://www.rcpp.org/ // http://adv-r.had.co.nz/Rcpp.html // http://gallery.rcpp.org/ // // [[Rcpp::export]] NumericVector timesTwo(NumericVector x) { return x * 2; } // You can include R code blocks in C++ files processed with sourceCpp // (useful for testing and development). The R code will be automatically // run after the compilation. // /*** R timesTwo(42) */ 3.2 구조 뜯어보기 Rcpp을 사용하기 위한 라이브러리 로드 #include &lt;Rcpp.h&gt; namespace를 지정하여 앞에서 언급했던 라이브러리명::함수명 대신 함수명으로도 사용이 가능 using namespace Rcpp; // : C++에서의 주석 기호 C++ 함수 정의 // [[Rcpp::export]] NumericVector timesTwo(NumericVector x) { return x * 2; } [[Rcpp::export]]는 C++에서 정의한 함수를 R에서 사용할 수 있도록 해주는 구문 C++에서 R을 실행해보는 청크(Chunk) /*** R timesTwo(42) */ 인터프리터 언어인 R과 달리 C++은 컴파일 언어이기 때문에, 파일 전체를 컴파일하며 오류가 있는지 체크한다. 따라서 R처럼 한 줄씩 실행하며 코드에 오류가 있는지 확인하기 어려운데, 이 청크를 이용하여 컴파일과 동시에 함수가 잘 정의되었는지 확인할 수 있다. "],["rcpp-Vector-matrix.html", "Chapter 4 Vector와 Matrix 4.1 데이터 타입 4.2 Vector 4.3 Matrix", " Chapter 4 Vector와 Matrix 4.1 데이터 타입 다음의 표에서 R과 Rcpp, C++의 Vector와 matrix에 해당하는 자료형을 비교하여 볼 수 있다. 자료형 R Rcpp (Vector) Rcpp (Matrix) Rcpp (Scalar) C++ (Scalar) 정수형 integer IntegerVector IntegerMatrix - int 실수형 numeric NumericVector NumericMatrix - double 문자열 character CharacterVector (StringVector) CharacterMatrix (StringMatrix) String string 논리형 logical LogicalVector LogicalMatrix - bool 4.2 Vector 설명의 편의를 위해 using namespace Rcpp;를 선언했다고 가정하자. (즉, Rcpp:: 부분을 생략한다는 의미이다.) 4.2.1 Vector 선언 다음과 같이 여러 방법으로 Vector를 생성할 수 있다. NumericVector뿐 아니라 다른 타입의 Vector도 동일한 방법으로 사용이 가능하다. // 값을 지정하지 않고 자료형과 변수만 선언 NumericVector a; // a &lt;- rep(0, 3) NumericVector a(3); // a &lt;- c(1,2,3) NumericVector a = {1,2,3}; // 또는 NumericVector a = NumericVector::create(1,2,3); 4.2.2 Vector 값 접근 R과 달리 Vector의 인덱스는 0부터 시작한다. (이는 Python이나 다른 프로그래밍 언어에서도 마찬가지이다.) Vector의 인덱싱은 다음과 같이 할 수 있다. NumericVector a = {1,2,3,4,5}; double a1 = a[0]; // 1을 a1에 저장 double a3 = a[2]; // 3을 a3에 저장 NumericVector b = a[Rcpp::Range(1, 3)]; // c(2,3,4)를 b에 저장 위와 같이 Vector의 인덱싱과 슬라이싱을 할 수 있지만, 슬라이싱이 아닌 경우의 Vector의 값을 여러개 가져오는 것은 불가능하다. 즉, 위의 a라는 Vector에서 2와 5의 값만을 동시에 가져오는 방법은 불가능하다. 4.2.3 Vector 관련 함수 a라는 Vector 타입의 변수가 있다고 가정하자. 4.2.3.1 a.length(), a.size() Vector a의 길이 반환 4.2.3.2 a.sort() Vector a를 오름차순으로 정렬 4.3 Matrix 4.3.1 Matrix 선언 // 값을 지정하지 않고 자료형과 변수만 선언 NumericMatrix A; // A1 &lt;- matrix(0, nrow = 2, ncol = 2) NumericMatrix A1(2); // A2 &lt;- matrix(0, nrow = 2, ncol = 3) NumericMatrix A2(2, 3); 4.3.2 Matrix 값 접근 Vector와 마찬가지로 matrix에서도 인덱싱과 슬라이싱을 할 수 있지만, 연속적인 위치가 아닌 값들을 동시에 가져오는 것은 불가능하다. 다음의 코드를 확인해보자. NumericMatrix A(5, 5); // A[2, 3] double a11 = A(1, 2); // A[1, ] NumericVector row1 = A(0, _); // 또는 NumericVector row1 = A.row(0); // A[, 2] NumericVector col1 = A(_, 1); // 또는 NumericVector col1 = A.column(1); // A[1:2, 3:4] NumericMatrix B = A(Range(0, 1), Range(2, 3)); 4.3.3 Matrix 관련 함수 A라는 Matrix 타입의 변수가 있다고 가정하자. 4.3.3.1 A.nrow(), A.rows() Matrix A의 행 개수 반환 4.3.3.2 A.ncol(), A.cols() Matrix A의 열 개수 반환 4.3.3.3 A.row(i) Matrix A의 i번쨰 행 반환 (return 타입은 Vector) 4.3.3.4 A.col(j) Matrix A의 j번쨰 열 반환 (return 타입은 Vector) 4.3.3.5 transpose(A) Matrix A를 transpose한 Matrix 반환 (return 타입은 Matrix) "],["rcpp-list-dataframe.html", "Chapter 5 List와 DataFrame 5.1 List 5.2 DataFrame", " Chapter 5 List와 DataFrame 5.1 List 5.2 DataFrame "],["eigen-basic.html", "Chapter 6 Eigen 자료형 6.1 Vector 6.2 Matrix", " Chapter 6 Eigen 자료형 6.1 Vector 6.2 Matrix "],["references.html", "References", " References "]]
